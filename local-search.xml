<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2024/03/05/Dynamic-Programming/"/>
    <url>/2024/03/05/Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{动态规划}<br>$$</p><hr><h3 id="一、算法原理"><a href="#一、算法原理" class="headerlink" title="一、算法原理"></a>一、算法原理</h3><p>将大问题拆分成子问题，对每个子问题只求一次，汇总得到整个问题的最优解。</p><h4 id="1-最优化原理"><a href="#1-最优化原理" class="headerlink" title="1. 最优化原理"></a>1. 最优化原理</h4><p>子问题的局部最优将导致整个问题的全局最优。后面的决策必须在前面的状态的基础上构成最优策略。</p><h4 id="2-无后效性原则"><a href="#2-无后效性原则" class="headerlink" title="2. 无后效性原则"></a>2. 无后效性原则</h4><p>某阶段的状态一旦确定，此后过程不受此前状态的影响。下一个状态只与当前状态有关。</p><hr><h3 id="二、基本构成"><a href="#二、基本构成" class="headerlink" title="二、基本构成"></a>二、基本构成</h3><h4 id="1-阶段"><a href="#1-阶段" class="headerlink" title="1. 阶段"></a>1. 阶段</h4><p>阶段根据时间和空间划分，能够将问题转化为多阶段决策过程。</p><h4 id="2-状态"><a href="#2-状态" class="headerlink" title="2. 状态"></a>2. 状态</h4><p>某一阶段的出发位置称为状态，一个阶段包含多个状态。</p><h4 id="3-决策"><a href="#3-决策" class="headerlink" title="3. 决策"></a>3. 决策</h4><p>在一定范围内，将一个状态转移到下一个阶段的对应状态。所有决策构成的整体称为策略。</p><h4 id="4-状态转移方程"><a href="#4-状态转移方程" class="headerlink" title="4. 状态转移方程"></a>4. 状态转移方程</h4><p>描述由第$i$阶到第$i+1$阶状态的演变规律的方程。</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note 24-02-18</title>
    <link href="/2024/02/18/Note-24-02-18/"/>
    <url>/2024/02/18/Note-24-02-18/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{图论笔记}\ \large\texttt{2024&#x2F;02&#x2F;18}<br>$$</p><hr><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>删除树上一点，所形成的最大子树最小的那个点是树的重心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(u,fa)&#123; <span class="hljs-comment">//若删除u，求最大子树大小</span><br>siz[u]=<span class="hljs-number">1</span>;<br>mx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> v:son &#123;<br><span class="hljs-built_in">dfs</span>(v);<br>diz[u]+=siz[v];<br>siz[v]=<span class="hljs-built_in">max</span>(mx,siz[v]);<br>&#125;<br>mx=<span class="hljs-built_in">max</span>(mx,n-siz[u]);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$。</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.树的重心如果不唯一，则至多有两个，且这两个重心相邻。<br>2.以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。<br>3.树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。<br>4.把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。<br>5.在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>() &#123;<br><span class="hljs-keyword">for</span> v:son &#123;<br>    求siz和mx;<br>&#125;<br>ans[u]=u;<br><span class="hljs-keyword">for</span> v:son &#123;<br>    重心向上跳<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(mx[p], siz[u]-siz[p])&lt;=<span class="hljs-number">0.5</span>*siz[u]) &#123;<br>ans[u]=p;<br>&#125;<br><span class="hljs-keyword">else</span> p=fa[p];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CF685B <a href="https://www.luogu.com.cn/problem/solution/CF685B">题解</a></p><hr><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p>找到树的一个重心，则问题的解可以分为路径经过重心的解和路径不经过中心的解两部分。<br>1.路径经过重心的解：设重心为树根，用数据结构记录重心到每个节点的路径信息。从中取出根的不同子树中的路径信息组合起来即为路径经过重心的解。<br>2.路径不经过重心的解：将重心和其关联的边删除，将分割出来的每棵树递归处理即可求出路<br>径不经过重心的解。</p><hr><h3 id="树上长度为k的路径"><a href="#树上长度为k的路径" class="headerlink" title="树上长度为k的路径"></a>树上长度为k的路径</h3><p>Luogu P3806 P4149</p><p>设置两个桶<code>s1</code>，<code>s2</code>，下标为长度，存储有无。<br><code>s1</code>：之前子树到$u$点距离；<br><code>s2</code>：当前子树到$u$点距离。<br>处理完每一棵子树，从<code>s2</code>中向<code>s1</code>匹配，寻找距离和为$k$的路径。<br>然后将<code>s2</code>信息转移到<code>s1</code>中。<br>若几个子树都没找到，<code>vis[u]=1</code>，对接下来的根节点继续操作。</p><p>$f_i$存有无长度为$i$的路径，数值$0$或$1$。<br>$g_i$存长度为$i$的路径的最小边数。<br>$a_i$存子树中的路径长度，用于精准清空。<br>$vis_u$表示$u$是否作为重心被删除了。<br>$dis_v$表示从$u$到$v$的距离。<br>$q_i$结构体，存路径距离<code>dis</code>和边数<code>cnt</code>。</p><p>新的子树中，把每一个点到$u$的距离都算一遍，长度+边数。<br>遍历每一条边，凑到$k$后，更新答案<code>ans=min(ans, q[j].cnt+g[k-q[j].dis])</code>。<br>每一次更新完，信息放到桶里，继续下一个子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(u) &#123;<br><span class="hljs-keyword">for</span> v:son &#123;<br><span class="hljs-built_in">dfs</span>(dis[v]);<br><span class="hljs-keyword">for</span> v:路径 &#123;<br>ans=...<br>&#125;<br><span class="hljs-keyword">for</span> v:路径 &#123;<br>更新桶<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;路径个数; ++j) &#123;<br>f[a[j]]=<span class="hljs-number">0</span>, g[a[j]]=<span class="hljs-number">0</span>; <span class="hljs-comment">//精准清空，</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求重心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//全局</span><br>weight <span class="hljs-comment">//重心作用大小</span><br>root <span class="hljs-comment">//重心位置</span><br><span class="hljs-built_in">dfsrt</span>() &#123;<br><span class="hljs-comment">//n-siz[u]换成weight-siz[u]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Luogu P3806 <a href="https://www.luogu.com.cn/problem/solution/P3806">题解</a><br>Luogu P4149 <a href="https://www.luogu.com.cn/problem/solution/P4149">题解</a></p><hr><h3 id="Luogu-P5306"><a href="#Luogu-P5306" class="headerlink" title="Luogu P5306"></a>Luogu P5306</h3><p>$w_i$：点前缀和，能提供的油量。<br>$d_i$：边前缀和，需要的油量。<br>$x$：到顶上后的剩余油量。<br>对于路径上的两个点$i,\ j$：<br>上行阶段满足$w_i-w_j\ge d_i-d_j$，变换得到$w_i-d_i\ge w_j-d_j$，记录沿途$max$值，记录存储于$s_1$。<br>下行阶段$x+w_{fa_j}\ge d_j$，变换得到$x+w_{fa_j}-d_j\ge0$，记录沿途$min$值，记录存储于$s_2$。<br>由于不知道会剩余多少，将所有$min$值求出扔到$s_2$后与$s_1$匹配，双指针。<br>Luogu P5306 <a href="https://www.luogu.com.cn/problem/solution/P3806">题解</a></p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note 24-02-04</title>
    <link href="/2024/02/04/Note-24-02-04/"/>
    <url>/2024/02/04/Note-24-02-04/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{随机化笔记}\ \large\texttt{24&#x2F;02&#x2F;04}<br>$$</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>非正解思路<br>并且C*F不接受申诉和重测</p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>该拿到的分都拿到了，会出现“罚坐”现象。<br>随机化——多拿一点分<br>有的不是正解，只能拿一般分</p><hr><h3 id="瞎子爬山"><a href="#瞎子爬山" class="headerlink" title="瞎子爬山"></a>瞎子爬山</h3><p>单峰山，局部择优，深搜改进。<br>如果新方案更好就转移到新方案。</p><p>每一步爬多长？一开始步子大一点，越往后步子更小。<br>步长减小可以按比例减小，随机化更平缓一些。<br>当步长足够小的时候，可以结束算法。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">climb</span><span class="hljs-params">()</span> </span>&#123;<br>node <span class="hljs-keyword">new</span>=<span class="hljs-built_in">rand</span>();<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> step=初始值, delta=<span class="hljs-number">0.985</span> <span class="hljs-comment">//delta belong to [0.985,0.999]</span><br><span class="hljs-keyword">while</span> (flag) &#123;<br>node best=<span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">for</span> (每一个方向, f) &#123;<br>node nxt=<span class="hljs-built_in">walk</span>(now, f, step);<br>best=<span class="hljs-built_in">max</span>(best, nxt);<br>&#125;<br><span class="hljs-keyword">if</span> (best!=now) now=best, flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> flag=<span class="hljs-number">0</span>;<br>step*=delta;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, now);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>瞎子爬山爬到最优解就不会往前走了。多峰就不会找到最优解。</p><p>改进：<br>1.多个瞎子一起爬，或一个瞎子爬多次。<br>2.加一点随机性或突变。</p><hr><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>灵感来源：中世纪铁匠打铁。<br>烧铁、很好延展性和韧性。<br>打铁，每一次形变很大，敲出大体形状。<br>低温，形变很小，适合制作更精细形状。</p><p>设置温度（步长），温度逐渐往下降，设置突变概率，找到最优解。到后期温度越低就很少遇到最劣解了。</p><p>如何选择合适突变概率$p$？<br>1.新状态与原状态差不太多，则应该有相对较大的概率跳过去。<br>2.越是退火的早期，越可能接受差的突变，越是退火的后期，越不能接受更差的改变。</p><p>温度$T$，新老状态差值为$\Delta E$，发生转移（修改最优解）概率为：<br>$$<br>P(\Delta E)&#x3D;<br>\begin{cases}<br>1,\ \text{新状态更优}\\<br>e^\frac{-\Delta E}{T},\ \text{新状态更劣}<br>\end{cases}<br>$$<br>$\Delta E$越大，越容易突变；$T$越大，越不容易突变。</p><p>初始温度$T_0$，降温系数$d&lt;1$，终止温度$T_k&gt;0$。<br>首先温度$T&#x3D;T_0$，每一次$T&#x3D;d\cdot T$，当$T&lt;T_k$时结束。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulate_anneal</span><span class="hljs-params">()</span> </span>&#123;<br>node now=<span class="hljs-built_in">rand</span>();<br><span class="hljs-type">double</span> T=<span class="hljs-number">1e5</span>, d=<span class="hljs-number">0.985</span>;<br><span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">1e-3</span>) &#123;<br>node nxt=<span class="hljs-built_in">Go</span>(now, 随机方向走一个距离);<br><span class="hljs-type">double</span> delta=<span class="hljs-built_in">del</span>(nxt, now);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>(-delta/t)&gt;<span class="hljs-built_in">random</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) now=nxt;<br>T*=d;<br>&#125;<br><span class="hljs-keyword">for</span> (若干次) ans=<span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">Go</span>(now, 随机方向走一个距离));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="实战：最小圆覆盖"><a href="#实战：最小圆覆盖" class="headerlink" title="实战：最小圆覆盖"></a>实战：最小圆覆盖</h3><p>二维平面随机撒点，找半径最小的圆，使得所有$n$个点在圆内。问圆心坐标和半径。</p><p>思路：<br>找到圆心就可以$O(n)$算出来。<br>对圆心进行模拟退火，对每一个圆心找到最小半径。</p><p>每一次$x$和$y$随机走，计算最小半径（最大距离），乘上突变概率。</p><hr><h3 id="遗传算法（简化版）"><a href="#遗传算法（简化版）" class="headerlink" title="遗传算法（简化版）"></a>遗传算法（简化版）</h3><p>多个瞎子扔到山脉中，多个瞎子一起爬。</p><p>一群猪扔到岛上，如果猪没死完，会怎样？（生物角度）</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> 猪群() &#123;<br><span class="hljs-keyword">for</span> (每一个周期) &#123;<br><span class="hljs-number">1.</span>身体不好，无法适应环境的猪大概率挂掉。<br><span class="hljs-number">2.</span>活下来的猪们生出了一群小猪。<br><span class="hljs-number">2.1</span>.一部分小猪继承了父母的特点，<br>在这个基础上产生了微小变异。<br><span class="hljs-number">2.2</span>.一部分小猪继承了父母的特点，<br>在这个基础上产生了大量变异。<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>100代以后，肯定比第一批更适应岛上的环境的。</p><p>遗传算法：<br>1.一个样本容纳量，每一个个体自然繁衍多少后代、后代突变概率和方式。<br>2.适当调整模拟轮数及样本容纳量的关系，以取得较好效果。（经验）<br>小猪定型后，可以代数减少，样本更多。<br>没突变完，就需要减少样本量，增加代数。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> 遗传算法() &#123;<br><span class="hljs-type">int</span> limit=<span class="hljs-number">1000</span>, tot=limit; <span class="hljs-comment">//样本总量&amp;繁衍后的总样本</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=limit; ++i) a[i]=<span class="hljs-built_in">rand</span>(); <span class="hljs-comment">//随机生成样本</span><br><span class="hljs-keyword">for</span> (每一个周期) &#123;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+tot+<span class="hljs-number">1</span>, cmp);<br>tot=limit; <span class="hljs-comment">//保留优秀的</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=limit; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">10</span>; ++j) a[++tot]=<span class="hljs-built_in">born1</span>(a[i]); <span class="hljs-comment">//遗传</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">3</span>; ++j) a[++tot]=<span class="hljs-built_in">born2</span>(a[i]); <span class="hljs-comment">//变异</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=tot; ++i) ans=<span class="hljs-built_in">max</span>(ans, a[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：<br>某一个随机样本特别好，几轮后就会发现所有样本都是它的孩子。<br>一个高原&#x2F;一个山峰，山峰更高，生在高原上的小猪全部活下来，生在山脚下的小猪全死了。<br>解决方法：<br>给小猪编一个姓氏，每一个样本限制每个姓氏的个数，保证多样性。</p><hr><h3 id="什么情况"><a href="#什么情况" class="headerlink" title="什么情况"></a>什么情况</h3><p>什么情况适合基于概率的演化算法？<br>1.先找正解，罚坐的时候才可以用。<br>2.需要决策的状态空间较小，或者看起来最优解比较密集。<br>例如，最小圆覆盖只有$x$和$y$两个维度，或者看起来最优解分布比较密集。<br>3.没有绑定<code>subtask</code>或多组数据才行，可能会被卡每组最后一个数据。</p><hr><h3 id="实战：方差-NOIP2021-T3"><a href="#实战：方差-NOIP2021-T3" class="headerlink" title="实战：方差 NOIP2021 T3"></a>实战：方差 NOIP2021 T3</h3><p><a href="https://www.luogu.com.cn/problem/P7962">原题传送门</a><br>给定一个长度为$n$的非严格递增正整数序列。<br>你每次可以选择一个位置$1&lt;i&lt;n$，使得$a_i&#x3D;a_{i+1}+a_{i-1}-a_i$。<br>问：这个序列的方差最少是多少。</p><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><p>完全随机，每次小概率大次数完成大概率。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7fffffff</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s, ss;<br><span class="hljs-type">int</span> b[N], a[N];<br>ll best=INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulation</span><span class="hljs-params">()</span> </span>&#123;<br>s=<span class="hljs-number">0</span>, ss=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) b[i]=a[i], s+=b[i], ss+=b[i]*b[i];<br>ll now=n*ss-s*s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> turn=<span class="hljs-number">1</span>; turn&lt;=<span class="hljs-number">30000</span>; ++turn) &#123;<br><span class="hljs-type">int</span> id=<span class="hljs-built_in">rand</span>()%(n<span class="hljs-number">-2</span>)+<span class="hljs-number">2</span>;<br>ll nxt=b[id<span class="hljs-number">-1</span>]+b[id+<span class="hljs-number">1</span>]-b[id];<br><span class="hljs-keyword">if</span> (nxt==b[id]) <span class="hljs-keyword">continue</span>;<br>ll t=s-b[id]+nxt, tt=ss-b[id]*b[id]+nxt*nxt;<br><span class="hljs-keyword">if</span> (now&gt;=n*tt-t*t || turn&lt;=<span class="hljs-number">2000</span>) &#123;<br>b[id]=nxt, s=t, ss=tt, now=n*tt-t*t, best=<span class="hljs-built_in">min</span>(best, now);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) a[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span> ((<span class="hljs-type">double</span>)<span class="hljs-built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="hljs-number">0.99</span>) &#123; <span class="hljs-comment">//极限卡时</span><br><span class="hljs-built_in">simulation</span>();<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, best);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Luogu 72pts<br><a href="https://www.luogu.com.cn/record/146101887">评测记录</a></p><h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><p>当取得最优解后，查分数组一定先变小再变大，发现：<br>1.每次操作相当于交换了查分数组；<br>2.答案最小时，差分数组总会是单独的。<br>状态空间显著变小，只可能往左放或往右放。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> T=<span class="hljs-number">1000</span>; T&gt;<span class="hljs-number">1e-8</span>; T*=<span class="hljs-number">0.996</span>) &#123;<br><span class="hljs-type">int</span> p=<span class="hljs-built_in">rad</span>(<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>);<br>vis[p]^=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> t=<span class="hljs-built_in">calc</span>();<br>ans=<span class="hljs-built_in">min</span>(ans, t);<br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">exp</span>(<span class="hljs-number">1.0</span>*<span class="hljs-built_in">fabs</span>(ans-t)/T)&gt;=<span class="hljs-built_in">rad2</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))) vis[p]^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> now=t;<br>&#125;<br></code></pre></td></tr></table></figure><p>纯随机化可以拿到满分。</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note 24-01-31</title>
    <link href="/2024/01/31/Note-24-01-31/"/>
    <url>/2024/01/31/Note-24-01-31/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{图论笔记}\ \large\texttt{2024&#x2F;01&#x2F;31}<br>$$</p><hr><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>时间复杂度$O(m\times n)$。<br>两点之间最短路最多包含所有点。如果一个点出现两次，就走了环，非负环不划算，负环没有最短路。<br>包含$k$条边的最短路可以由最多包含$k-1$条边的最短路加一条边来获得,这个操作是“松弛”。<br>如果某一个点的最短路被更新了，这个点就有能力更新它所连接的点。<br>当所有边不满足$d_u+w&lt;d_v$时，最短路不会再改变了。每条边进行$n-1$遍“松弛”操作。<br>检查，如果有一条边还能松弛，则有负环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF;<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n<span class="hljs-number">-1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) &#123;<br>u=e[j].u, v=e[j].v, w=e[j].w;<br><span class="hljs-keyword">if</span> (d[i]&lt;INF) d[v]=<span class="hljs-built_in">min</span>(d[v], d[u]+w); <span class="hljs-comment">//松弛</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)<br><span class="hljs-keyword">if</span> (d[e[i].u]+w&lt;d[e[i].v]) ; <span class="hljs-comment">//存在负环</span><br></code></pre></td></tr></table></figure><hr><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>全称Shortest Path Faster Algorithm，于1994年被西安交通大学段凡丁发明。<br>$n\le10^5$，可以有负权，可以判断负环。<br>时间复杂度$O(k\times m)$，$k$一般小于$2$。</p><p>如果一个点没有被改变，再判断能否“松弛”，是没有意义的。只有它被更新了才检查，用这个优化。</p><p>建立一个队列，初始点s，将它所更新的点压入队列，不更新的不管它。做完了弹出，取出下一个点继续更新。当这个队列空了，就意味着没有可以更新的点了，结束。<br>一个点可能多次进入队列，只要被更新就进入队列。每个顶点进入队列不会超过$n$次，如果超过$n$次就意味着存在负环。</p><p>手写队列长度为$10\times n$，也可以用长度为$n+1$的循环队列，也可以用<code>STL::queue</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//队列</span><br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt)); <span class="hljs-comment">//进入队列次数</span><br><span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq)); <span class="hljs-comment">//标记是否在队列里面</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF; <span class="hljs-comment">//最短路</span><br>d[s]=<span class="hljs-number">0</span>; <span class="hljs-comment">//起点距离为0</span><br>cnt[s]=<span class="hljs-number">1</span>; <span class="hljs-comment">//进入队列次数</span><br>q.<span class="hljs-built_in">push</span>(s); <span class="hljs-comment">//进入队列</span><br>inq[s]=<span class="hljs-number">1</span>; <span class="hljs-comment">//打标记</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取出点</span><br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出</span><br>inq[u]=<span class="hljs-number">0</span>; <span class="hljs-comment">//取消标记</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=g[u]; i&gt;<span class="hljs-number">0</span>; i=e[i].next) &#123; <span class="hljs-comment">//遍历所连接的点</span><br><span class="hljs-type">int</span> v=e[i].v, w=e[i].w; <span class="hljs-comment">//改名，减少出错</span><br><span class="hljs-keyword">if</span> (d[u]+w&lt;d[v]) &#123; <span class="hljs-comment">//可以松弛</span><br>d[v]=d[u]+w; <span class="hljs-comment">//更新</span><br><span class="hljs-keyword">if</span> (!inq[v]) &#123; <span class="hljs-comment">//如果不在队列里面</span><br>q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">//进入队列</span><br>inq[v]=<span class="hljs-number">1</span>; <span class="hljs-comment">//在队列里，打标记</span><br>cnt[v]++; <span class="hljs-comment">//进入队列次数+1</span><br><span class="hljs-keyword">if</span> (cnt[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//存在负环</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//没有负环</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SLF优化：<br>Small Label Fiest策略<br>如果一个点被更新地很短，前面的就会被浪费。<br>如果点$v$被更新，队首为$t$，且$d_v$&lt;$d_t$，就把$v$放在队首。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">//队列</span><br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(s)); <span class="hljs-comment">//进入队列次数</span><br><span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq)); <span class="hljs-comment">//标记是否在队列里面</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF;  <span class="hljs-comment">//最短路</span><br>d[s]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//起点距离为0</span><br>cnt[s]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//进入队列次数</span><br>q.<span class="hljs-built_in">push_front</span>(s);  <span class="hljs-comment">//进入队列</span><br>inq[s]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//打标记</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//取出点</span><br>q.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">//弹出</span><br>inq[u]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//取消标记</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=g[u]; i&gt;<span class="hljs-number">0</span>; i=e[i].next) &#123;  <span class="hljs-comment">//遍历所连接的点</span><br><span class="hljs-type">int</span> v=e[i].v, w=e[i].w;  <span class="hljs-comment">//改名，减少出错</span><br><span class="hljs-keyword">if</span> (d[u]+w&lt;d[v]) &#123;  <span class="hljs-comment">//可以松弛</span><br>d[v]=d[u]+w;  <span class="hljs-comment">//更新</span><br><span class="hljs-keyword">if</span> (!inq[v]) &#123;  <span class="hljs-comment">//如果不在队列里面</span><br><span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()&amp;&amp;d[v]&lt;=d[q.<span class="hljs-built_in">front</span>()]) q.<span class="hljs-built_in">push_front</span>(v);  <span class="hljs-comment">//如果比队首小，放前面</span><br><span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(v);  <span class="hljs-comment">//如果挺大，放后面</span><br>inq[v]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//在队列里，打标记</span><br>cnt[v]++;  <span class="hljs-comment">//进入队列次数+1</span><br><span class="hljs-keyword">if</span> (cnt[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//存在负环</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//没有负环</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About This Website</title>
    <link href="/2024/01/30/About-This-Website/"/>
    <url>/2024/01/30/About-This-Website/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{关于这个网站}<br>$$</p><hr><p>Q: 这个网站是谁建的？<br>A: <a href="/2023/12/02/About-Me">我</a>建的。</p><p>Q: 为什么网站是英文的，内容是中文的？<br>A: 不知道为什么，一换成中文就乱码，并且我英语水平不是很高。</p><p>Q: 为什么文章很简单？<br>A: 我是蒟蒻。</p><p>Q: 为什么图片加载很慢？<br>A: 懒得配staic，先将就着看吧。</p><p>Q: 为什么滑动时会抖动？<br>A: 标签栏做了毛玻璃特效。</p><p>Q: 为什么没有备案？<br>A: 因为注册者还没有满16岁。</p>]]></content>
    
    
    <categories>
      
      <category>Introductions</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note 24-01-30</title>
    <link href="/2024/01/30/Note-24-01-30/"/>
    <url>/2024/01/30/Note-24-01-30/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{图论笔记}\ \large\texttt{2024&#x2F;01&#x2F;30}<br>$$</p><hr><h3 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h3><p>考试中，图论数据量都是$10^5$量级的，所以用邻接表。<br>数组的定义记住估算一下空间，对数组大小有概念。<br>二维int数组最大开到$5000\times5000$<br>万不得已不要定义在主函数内。<br>规范变量命名。  </p><hr><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p><code>STL::memset</code><br>头文件<code>cstring</code><br>使用方法<code>memset(地址, 数值, 长度)</code><br>将<code>地址</code>的每一个字节填充<code>数值</code><br>最大值填充<code>0x3F</code>即可</p><hr><h3 id="多少条边"><a href="#多少条边" class="headerlink" title="多少条边"></a>多少条边</h3><p>有向图：<br>$C^2_n&#x3D;\frac{A^2_n}{A^2_2}&#x3D;\frac{n\times(n-1)}{2}$<br>无向图：<br>$A^2_n&#x3D;n\times(n-1)$</p><hr><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>空间复杂度$O(n^2)$，全部遍历时间复杂度$O(n^2)$</p><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>稀疏图用，常考常用。<br>每一个点接的点在对应点后练成一个链，vector或数组模拟。<br>遍历全图时间复杂度$O(m)$</p><hr><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>集合的传递性：<br>$若A&gt;B，B&gt;C，则A&gt;C。$</p><p>最短路径 ：<br>$d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j])$</p><p>最大边最小（最小生成树）：<br>$d[i][j]&#x3D;min(d[i][j],max(d[i][j],d[k][j]))$</p><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆就是一棵完全二叉树，$n$个节点。</p><p>以小根堆为例，从上到下，从左到右编号，$a_i\le a_{2i}$，$a_i\le a_{2i+1}$，这个父亲节点小于左儿子，也小于右儿子。这一棵完全二叉树称为小根堆，最小值是$a_1$，查询时间复杂度$O(1)$。</p><p>每一次修改、插入或删除，变化以后还是满足小根堆。</p><p><strong>上浮操作</strong><br>先放在后面，不符合把儿子和父亲换一下，一层层检查交换，$a_i$与$a_{\frac{i}{2}}$比较。插入时间复杂度$O(\log n)$。修改同理。</p><p><strong>下沉操作</strong><br>删除就是把最后一个移到删除的数上，与下面的比较，不符合就交换。时间复杂度$O(\log n)$。</p><hr><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><code>STL::priority_queue</code></p><p>在一个长度为$n$的序列中，可以完成两个操作：<br>1.询问最大值最小值<br>2.插入一个数</p><p>m次操作，时间复杂度$O(m\log n)$</p><hr><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>单源最短路算法：只有一个源点作为起点。<br>暴力$O(n^2)$<br>堆优化$O(m\log m)$<br>不能有负边存在</p><p>源点$s$<br>最短路$d_i$<br>标记数组$v_i$<br>初始条件$d_1&#x3D;0$，其余为$\infin$。</p><p>贪心思想<br>因为没有负边，所以已求点最短路不会再变化。<br>两个集合，已求点（白点）和未求点（蓝点）。</p><p>第一步：蓝点中找一个与白点距离最近的。<br>第二步：将这个点变为白点，用这个点更新蓝点距离。<br>$d_x+a_{x,y}$更新$d_y$，$x$为白点，$y$为蓝点。<br>第三步：重复，直到全部变成白点。</p><p>暴力代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i<span class="hljs-number">-1</span>; i&lt;=n; ++i) d[i]=INF;<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i） &#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">-1</span>, mn=INF; <span class="hljs-comment">// x不设置初始值可能会RE</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j) &#123;<br><span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; d[j]&lt;mn) mn=d[x=j];<br>&#125;<br><span class="hljs-keyword">if</span> (x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 这一步可选，意味着图是断开的</span><br>vis[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j) &#123;<br><span class="hljs-keyword">if</span> (!vis[j]) d[j]=<span class="hljs-built_in">min</span>(d[j], d[x]+a[x][j]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种写法，一开始就把起点变成白点，并预处理好起点所连接的边，下一次$1$就不用找了。代码较为麻烦。</p><p>$d_i$也可以维护最大边和最短边。<br>最大边最小：$d_i&#x3D;min(d_i,\ max(d_j,\ a_{j,i}))$<br>最小边最大：$d_i&#x3D;max(d_i,\ min(d_j,\ a_{j,i}))$</p><p><a href="https://oi-wiki.org/graph/shortest-path/#%E5%AE%9E%E7%8E%B0_2">源码</a></p><hr><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>它死了</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Periodic Table</title>
    <link href="/2024/01/25/Periodic-Table/"/>
    <url>/2024/01/25/Periodic-Table/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{元素周期表}<br>$$</p><hr><p>很抱歉，这篇文章还<strong>没写完</strong>。<br>预计交稿时间2024&#x2F;02&#x2F;05</p><hr><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><p>摘自人教版化学必修一</p><img src="../../../../img/07-01.jpg" alt="07-01" style="zoom:50%;" /><hr><h3 id="背诵区域"><a href="#背诵区域" class="headerlink" title="背诵区域"></a>背诵区域</h3><table><thead><tr><th align="center">周期</th><th align="center">IA</th><th align="center">IIA</th><th align="center">IIIB</th><th align="center">IVB</th><th align="center">VB</th><th align="center">VIB</th><th align="center">VIIB</th><th align="center">VIII</th><th></th><th></th><th align="center">IB</th><th align="center">IIB</th><th align="center">IIIA</th><th align="center">IVA</th><th align="center">VA</th><th align="center">VIA</th><th align="center">VIIA</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1 H<br />氢<br />qīng</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2 He<br />氦<br />hài</td></tr><tr><td align="center">2</td><td align="center">3 Li<br />锂<br />lǐ</td><td align="center">4 Be<br />铍 pí</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center">5 B<br />硼<br />péng</td><td align="center">6 C<br />碳<br />tàn</td><td align="center">7 N<br />氮<br />dàn</td><td align="center">8 O<br />氧<br />yǎng</td><td align="center">9 F<br />氟<br />fú</td><td align="center">10 Ne<br />氖<br />nǎi</td></tr><tr><td align="center">3</td><td align="center">11 Na<br />钠<br />nà</td><td align="center">12 Mg<br />镁<br />m</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center">13 Al<br />铝<br />lǚ</td><td align="center">14 Si<br />硅<br />guī</td><td align="center">15 P<br />磷<br />lín</td><td align="center">16 S<br />硫<br />liú</td><td align="center">17 Cl<br />氯<br />lǜ</td><td align="center">18 Ar<br />氩<br />yà</td></tr><tr><td align="center">4</td><td align="center">19 K<br />钾<br />jiǎ</td><td align="center">20 Ca<br />钙<br />gài</td><td align="center">21 Sc<br />钪<br />kàng</td><td align="center">22 Ti<br />钛<br />tài</td><td align="center">23 V<br />钒<br />fán</td><td align="center">24 Cr<br />铬<br />gè</td><td align="center">25 Mn<br />锰<br />měng</td><td align="center">26 Fe<br />铁<br />tiě</td><td>27 Co<br />钴<br />gǔ</td><td>28 Ni<br />镍<br />niè</td><td align="center">29 Cu<br />铜<br />tóng</td><td align="center">30 Zn<br />锌<br />xīn</td><td align="center">31 Ga<br />镓<br />jiā</td><td align="center">32 Ge<br />锗<br />zhě</td><td align="center">33 As<br />砷<br />shēn</td><td align="center">34 Se<br />硒<br />xī</td><td align="center">35 Br<br />溴<br />xiù</td><td align="center">36 Kr<br />氪<br />kè</td></tr><tr><td align="center">5</td><td align="center">37 Rb<br />铷<br />rú</td><td align="center">38 Sr</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">55 Cs<br />铯<br />sè</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">87 Fr<br />钫<br />fāng</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Chemistry</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuel Card - SHMCEE 2023</title>
    <link href="/2024/01/11/Fuel-Card-SHMCEE-2023/"/>
    <url>/2024/01/11/Fuel-Card-SHMCEE-2023/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{加油卡 - 2023上海数学中考}<br>$$</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>“中国石化”推出促销活动，一张加油卡的面值是1000元，打九折出售。使用这张加油卡加油，每一升油，油的单价降低0.30元。假设这张加油卡的面值能够一次性全部用完。<br>(1) 他实际花了多少钱购买会员卡？<br>(2) 减价后每升油的单价为y元&#x2F;升，原价为x元&#x2F;升，求y关于x的函数解析式。（不用写出定义域）<br>(3) 油的原价是7.30元&#x2F;升，求优惠后油的单价比原价便宜多少元？</p><hr><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>(1) 900元<br>(2) y&#x3D;0.9x-0.27<br>(3) 1元</p><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>(1) 由$1000\times\frac{9}{10}&#x3D;900$，易得他花了900元。</p><p>(2) 方法一：<br>由原价为$x$元&#x2F;升，可得在加油时实际油价为$(x-0.3)$元&#x2F;升。<br>由于加油卡面值为$1000$元，买完卡后可以以降价后的价钱加价值为$1000$元的油，所以一共可以加$\frac{1000}{x-0.3}$升油。<br>因为总共花了$900$元就买下了$1000$元的加油卡，根据每一升油的价格为总价除以体积，得出油价为$\frac{900}{\frac{1000}{x-0.3}}$元&#x2F;升，化简得$(0.9x-0.27)$元&#x2F;升。<br>故答案为$y&#x3D;0.9x-0.27$。</p><p>方法二：<br>既然$1000$元当成$900$元卖了，就理解为每升汽油的油价都打了九折。乘上先前的降价，即为$0.9\times(x-0.3)$元&#x2F;升，化简得$(0.9x-0.27)$元&#x2F;升。<br>故答案为$y&#x3D;0.9x-0.27$。</p><p>(3) 将$x&#x3D;7.3$代入原式，得$y&#x3D;6.3$，价格差为$7.3-6.3&#x3D;1$元。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><p>这道题重在理解题意。<br>第一小问是送分题，直接算折扣后的即可；第三小问代入作差即可。<br>难度在第二小问，需要辨析是$y&#x3D;0.9(x-0.3)$而不是$y&#x3D;0.9x-0.3$。可以通过“九折”的作用范围来理解，可以结合复合函数$u&#x3D;x-0.3$，$y&#x3D;0.9u$来理解，也可以通过上述严格证明来验证。</p><h4 id="争议与反思"><a href="#争议与反思" class="headerlink" title="争议与反思"></a>争议与反思</h4><p>好多人抱怨题目都看不懂，也有许多人质疑出题人的语言水平。<br>放在现在来看，这道题没有很严重的问题。当然这是站在全面分析的基础上，考场里自然没有时间做出详尽的证明过程，所以很多人确实理解不了“九折”到底打在哪里。<br>题目读不懂的原因也可能是生活经验不足。例如商店买东西打折时，没有认真计算过哪个划算，缺乏生活中解决实际数学问题的经验。</p><h4 id="出题方向"><a href="#出题方向" class="headerlink" title="出题方向"></a>出题方向</h4><p>这道题充分体现了上海中考的考试方向：实践应用、生活理解和思维贯通，同时也考验了考生的数学阅读理解能力。<br>这也是全国各省市的新中考考试方向。考生要应注意提升阅读速度和理解能力。</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Mathematics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>An Example of Equivalent Resistance</title>
    <link href="/2023/12/30/An-Example-of-Equivalent-Resistance/"/>
    <url>/2023/12/30/An-Example-of-Equivalent-Resistance/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{等效电阻 例题}<br>$$</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一道物理题，是初高衔接课材料里的题；老师却不讲，因为它严重超纲。<br>拍照搜题搜不到，于是我决定自己做。找寻答案的过程一波三折，很有参考价值。我把这道题的完整结题过程记录了下来，方便大家学习。<br>在此特别感谢<a href="https://wild-donkey.github.io/">硕硕</a>和学校物理老师们给予的帮助！</p><hr><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如图所示，所有电阻的阻值都等于$R$，求A、B间的等效电阻。<br><img src="../../../../img/05-01.jpg" alt="05-01" style="zoom:50%;" /><br>注意：中间没有连接，注意观察圆点。</p><hr><h3 id="思路过程"><a href="#思路过程" class="headerlink" title="思路过程"></a>思路过程</h3><p>特别说明：以下三个思路都是<strong>错的</strong>，请移步<strong>正解</strong>找寻答案，这里只是简单说明思路过程。<br>变量命名不标准，没有按照题目要求，请见谅。</p><h4 id="错误解法1-Dijkstra"><a href="#错误解法1-Dijkstra" class="headerlink" title="错误解法1 - Dijkstra"></a>错误解法1 - Dijkstra</h4><p>思路来自<a href="https://www.luogu.com.cn/user/958730">Algo_3F</a>。<br><img src="../../../../img/05-02.jpg" alt="05-02" style="zoom:25%;" /><br>显然，这个答案小于$R$，因为有电流通过上面的电路中。</p><h4 id="错误解法2-节点法"><a href="#错误解法2-节点法" class="headerlink" title="错误解法2 - 节点法"></a>错误解法2 - 节点法</h4><p>首先，我先用节点法尝试了一下。<br>标记电势，考虑到已经有了A、B，使用小写字母代替，电势由高到低分别标记为$a\rightarrow b\rightarrow c\rightarrow d$。<br><img src="../../../../img/05-03.jpg" alt="05-03" style="zoom:50%;" /><br>不难发现，此时电路变为了三段并联。其中，$a\rightarrow d$先并联了一个单独的电阻，然后$a\rightarrow b$中有两个电阻，$b\rightarrow c$中有三个电阻，$c\rightarrow d$中有两个电阻。<br>那答案就迎刃而解了，ab段电阻$\frac{1}{2}R$，bc段电阻$\frac{1}{3}R$，cd段电阻$\frac{1}{2}R$，ad两个支路分别为$\frac{4}{3}R$和$R$，并起来一共$\frac{4}{7}R$。<br>显然，这道题不是这么简单的。注意看，在刚才的过程中，我们将所有连接b、c两个电势的都视作了并联，但事实上在中间交叉的电阻中，中间交点并不与其他等电势的地方相接。倒回去，如果按照这个思路，电路图应该如下图所示，其中颜色与上图对应。<br><img src="../../../../img/05-04.jpg" alt="05-04" style="zoom:50%;" /><br>我们无法证明这种方法的正确性，因为这种方法多连了两根导线，把电阻扯到一边去了，相当于分摊了电流。因此这个答案不一定是正确的。经过后续计算得知，这种方法是错误的。</p><h4 id="错误解法3-对称性"><a href="#错误解法3-对称性" class="headerlink" title="错误解法3 - 对称性"></a>错误解法3 - 对称性</h4><p>接下来尝试化简电路，化简结果如下，其中最中间奇怪方式连接的电阻是原图中最上面的与AB平行的电阻。<br><img src="../../../../img/05-05.jpg" alt="05-05" style="zoom:75%;" /><br>然后就没有然后了，接下来问的硕硕才知道解法。<br>显然，最上面的电阻是并联进去的，所以先不考虑，先把下面复杂的单独拆出来。根据对称性，上下两个支路电流相等，所以设总电流为$I$，则每条支路的电流都为$\frac{I}{2}$，如图所示。<br><img src="../../../../img/05-06.jpg" alt="05-06" style="zoom:75%;" /><br>因为每个电阻是相等的，设每个电阻为$r$，总电阻为$R$。设总电压为$U$，根据对称性设左上和右下电阻为$r$，则左下右上电阻为$2r$，因为电流相等，电阻为二倍，所以电压为二倍。<br>这样列出等量关系式$U&#x3D;3u$，$r&#x3D;\frac{u}{\frac{I}{2}}&#x3D;\frac{2u}{I}$，$R&#x3D;\frac{U}{I}&#x3D;\frac{3u}{I}&#x3D;\frac{3}{2}\times\frac{2u}{I}&#x3D;\frac{3}{2}r$<br>所以这段电路的总电阻是单个电阻的$\frac{3}{2}$倍，和之前单拎的电阻并联起来就是$\frac{1}{\frac{2}{3r}+\frac{1}{r}}&#x3D;\frac{3}{5}r$<br>就这么结束了，我和硕硕都觉得这是个完美的解法。然而我们忽略了一个关键点：没考虑中间电阻，即没考虑标蓝的电流。这个电流的加入会导致左上、右下电流增加，导致电压不为二倍。<br><img src="../../../../img/05-07.jpg" alt="05-07" style="zoom:25%;" /></p><h4 id="错误解法4-等电流"><a href="#错误解法4-等电流" class="headerlink" title="错误解法4 - 等电流"></a>错误解法4 - 等电流</h4><p>按照分电流的思路继续往前走，我们发现在这个复杂电路中共有三条电流，如图是这三条电流分别途径的电路。<br><img src="../../../../img/05-08.jpg" alt="05-08" style="zoom:50%;" /><br><img src="../../../../img/05-09.jpg" alt="05-09" style="zoom:50%;" /><br><img src="../../../../img/05-10.jpg" alt="05-10" style="zoom:50%;" /><br>不难看出，这三条电路的电阻相等，电压相等都等于电源电压，所以电流也相等，相当于三个等流并联，得到这部分电阻为$R$，再并上单个的电阻，总电阻为$\frac{1}{2}R$。<br>很简单，很直接，但这个思路是错的。硕硕说欧姆定律的应用条件是闭合电路，但这个电路不闭合，所以不能推出等流这一结论。</p><hr><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>正解由硕硕提供，我整理的过程稍微有些不规范。<br>思路：列方程求出中间电流，进而求出总电流和总电压的关系。</p><p>首先考虑下面复杂电路的电阻，将直接连接$AB$的电阻分开，剩下电路化简如下。<br><img src="../../../../img/05-11.jpg" alt="05-11" style="zoom:75%;" /><br>设这部分电路总电压为$U$，通过$R_1$的电流为$I$，通过$R_0$的电流为$i$，$R_1$两端电压为$u$。<br>由对称性可得，$I_{R_2}&#x3D;I$，$U_{R_2}&#x3D;u$。<br>因为$R_0$与$R_5$、$R_6$一起分走$R_1$电流，所以$I_{R_5}&#x3D;I_{R_6}&#x3D;I_{R_1}-I_{R_0}&#x3D;I-i$。$I_{R_3}$、$I_{R_4}$由对称性也可得。故该段电路总电流$I_{sum}&#x3D;I_{R_1}+I_{R_3}&#x3D;2I-i$<br>因为$R_1$、$R_5$和$R_6$构成串联，所以$U_{R_5}+U_{R_6}&#x3D;U-U_{R_1}&#x3D;U-u$。因为$R_5&#x3D;R_6$，根据正比分压可得$U_5&#x3D;U_6&#x3D;\frac{U-u}{2}$。$U_{R_3}$、$U_{R_4}$由对称性也可得。<br>因为$R_1$、$R_0$和$R_2$构成串联，所以$U_{R_0}&#x3D;U-U_{R_1}-U_{R_2}&#x3D;U-2u$。</p><p>由此，所有电阻的电流电压均已得，故可求电阻：<br>$U_{R_0}&#x3D;U-2u,\ I_{R_0}&#x3D;i,\ R_0&#x3D;\frac{U-2u}{i}$<br>$U_{R_1}&#x3D;u,\ I_{R_1}&#x3D;I,\ R_1&#x3D;\frac{u}{I}$<br>$U_{R_2}&#x3D;u,\ I_{R_2}&#x3D;I,\ R_2&#x3D;\frac{u}{I}$<br>$U_{R_3}&#x3D;\frac{U-u}{2},\ I_{R_3}&#x3D;I-i,\ R_3&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_4}&#x3D;\frac{U-u}{2},\ I_{R_4}&#x3D;I-i,\ R_4&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_5}&#x3D;\frac{U-u}{2},\ I_{R_5}&#x3D;I-i,\ R_5&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_6}&#x3D;\frac{U-u}{2},\ I_{R_6}&#x3D;I-i,\ R_6&#x3D;\frac{U-u}{2I-2i}$<br>$U_{sum}&#x3D;U,\ I_{sum}&#x3D;2I-i,\ R_{sum}&#x3D;\frac{U}{2I-i}$</p><p>因为每个电阻都相等，得$R_0&#x3D;R_1&#x3D;R_3$，即$\frac{U-2u}{i}&#x3D;\frac{u}{I}&#x3D;\frac{U-u}{2I-2i}$，解得$i&#x3D;\frac{1}{3}I$。将其代入，得$\frac{U-2u}{i}&#x3D;\frac{u}{3i}&#x3D;\frac{U-u}{4i}$，解得$U&#x3D;\frac{7}{3}u$<br>$R_{sum}&#x3D;\frac{U}{2I-i}&#x3D;\frac{\frac{7}{3}u}{\frac{5}{3}I}&#x3D;\frac{7}{5}\times\frac{u}{I}&#x3D;\frac{7}{5}R_2&#x3D;\frac{7}{5}R$<br>故这段电路的总电阻为$\frac{7}{5}R$，再与原先阻值为$R$的电阻并联，得到$\frac{1}{\frac{5}{7R}+\frac{1}{R}}&#x3D;\frac{7}{12}R$<br>故答案为$\frac{7}{12}R$</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>硕硕的一句话足以概括<br><img src="../../../../img/05-12.jpg" alt="05-12" style="zoom:25%;" /></p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>结束了，题做出来了。<br>硕硕说，这个题目很有意思，让他想起了中学物理的知识。<br>我觉得这个题目挺难的，但有意思的地方在解题思路上。一次一次的错误，一次一次的改正。如果这个题给我在考试里做，我可能直接就放弃了，也不会这么曲折地做出来。当然最终找到答案也是十分开心的。</p><p>最后硕硕提出用模拟软件校验一下，相差不大，所以这个答案应该是对的。<br>如果你认为这个答案不对，欢迎指出，万一这个答案也是错误的呢？也许这个思路也会成错误解法之一。</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Physics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Finding LCA</title>
    <link href="/2023/12/28/Finding-LCA/"/>
    <url>/2023/12/28/Finding-LCA/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{LCA查找}<br>$$</p><hr><hr><p>很抱歉，这篇文章还<strong>没写完</strong>。<br>预计交稿时间2024&#x2F;02&#x2F;04</p><hr><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>最近公共祖先</p><hr><h3 id="二、前置算法"><a href="#二、前置算法" class="headerlink" title="二、前置算法"></a>二、前置算法</h3><p>由图建树、树的遍历、DFS序、blablabla</p><hr><h3 id="三、求解方法"><a href="#三、求解方法" class="headerlink" title="三、求解方法"></a>三、求解方法</h3><h4 id="1-暴力求LCA"><a href="#1-暴力求LCA" class="headerlink" title="1. 暴力求LCA"></a>1. 暴力求LCA</h4><p>不想写QWQ</p><h4 id="2-倍增求LCA"><a href="#2-倍增求LCA" class="headerlink" title="2. 倍增求LCA"></a>2. 倍增求LCA</h4><p>不想写QWQ</p><h4 id="3-DFS求LCA"><a href="#3-DFS求LCA" class="headerlink" title="3. DFS求LCA"></a>3. DFS求LCA</h4><p>不想写QWQ</p><h4 id="4-Tarjan求LCA"><a href="#4-Tarjan求LCA" class="headerlink" title="4. Tarjan求LCA"></a>4. Tarjan求LCA</h4><p>不想写QWQ</p><hr><h3 id="笔记-树上单源最短路"><a href="#笔记-树上单源最短路" class="headerlink" title="笔记 - 树上单源最短路"></a>笔记 - 树上单源最短路</h3><p>换根，DFN序存为数组，区间为字数，端点左边减，右边加<br>不想写QWQ</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Salt Production from Seawater</title>
    <link href="/2023/12/23/Salt-Production-from-Seawater/"/>
    <url>/2023/12/23/Salt-Production-from-Seawater/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{海水制盐}<br>$$</p><hr><h3 id="一、晾晒粗盐"><a href="#一、晾晒粗盐" class="headerlink" title="一、晾晒粗盐"></a>一、晾晒粗盐</h3><h4 id="1-蒸发池"><a href="#1-蒸发池" class="headerlink" title="1. 蒸发池"></a>1. 蒸发池</h4><p>海水在蒸发池中借助光能和风能蒸发出大量水分，这个过程要持续几天。<br>在这个过程中，$NaCl$或恰为或接近饱和状态。</p><h4 id="2-结晶池"><a href="#2-结晶池" class="headerlink" title="2. 结晶池"></a>2. 结晶池</h4><p>浓海水进入这里，继续晾晒蒸发，待底部出现大量$NaCl$结晶后停止。<br>在这个过程中，浓海水被分为粗盐和母液。<br>粗盐中的主要成分是$NaCl$，混有少量$Na_2SO_4$、$CaCl_2$和$MgCl_2$等杂质。<br>母液又称盐卤、苦卤，是$NaCl$的饱和溶液，也是化学工业的重要原料。</p><hr><h3 id="二、粗盐精制"><a href="#二、粗盐精制" class="headerlink" title="二、粗盐精制"></a>二、粗盐精制</h3><p>粗盐溶液中含有$H_2O$、泥沙、$Na^+$、$Cl^-$、$SO_4^{2-}$、$Ca^{2+}$、$Mg^{2+}$及其他杂质。<br>在精制中，主要考虑去除泥沙、钙镁离子和硫酸根。</p><h4 id="第一步：去除泥沙等难溶性杂质"><a href="#第一步：去除泥沙等难溶性杂质" class="headerlink" title="第一步：去除泥沙等难溶性杂质"></a>第一步：去除泥沙等难溶性杂质</h4><p>过滤即可，实验室操作中注意玻璃棒引流。</p><h4 id="第二步：去除-Mg-2-离子"><a href="#第二步：去除-Mg-2-离子" class="headerlink" title="第二步：去除$Mg^{2+}$离子"></a>第二步：去除$Mg^{2+}$离子</h4><p>向溶液中加入$NaOH$<br>要求：过量<br>化学方程式：$MgCl_2+2NaOH\xlongequal{\hspace{1cm}}Mg(OH)_2\downarrow+2NaCl$<br>离子方程式：$Mg^{2+}+2OH^-\xlongequal{\hspace{1cm}}Mg(OH)_2\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$Na_2SO_4$、$CaCl_2$、$NaOH$<br>剩余离子：$Na^+$、$Cl^-$、$SO_4^{2+}$、$Ca^{2+}$、$OH^-$<br>剩余沉淀：$Mg(OH)_2$<br>注：不建议换成$Ca(OH)_2$，首先是溶解度小，其次是引进了更多的$Ca^{2+}$，导致第四步需要加入更多的$Na_2CO_3$</p><h4 id="第三步：去除-SO-4-2-离子"><a href="#第三步：去除-SO-4-2-离子" class="headerlink" title="第三步：去除$SO_4^{2-}$离子"></a>第三步：去除$SO_4^{2-}$离子</h4><p>向溶液中加入$BaCl_2$<br>要求：过量<br>化学方程式：$Na_2SO_4+BaCl_2\xlongequal{\hspace{1cm}}BaSO_4\downarrow+2NaCl$<br>离子方程式：$SO_4^{2-}+Ba^{2+}\xlongequal{\hspace{1cm}}BaSO_4\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$CaCl_2$、$NaOH$、$BaCl_2$<br>剩余离子：$Na^+$、$Cl^-$、$Ca^{2+}$、$OH^-$、$Ba^{2+}$<br>剩余沉淀：$Mg(OH)_2$、$BaSO_4$</p><h4 id="第四步：去除-Ca-2-和-Ba-2-离子"><a href="#第四步：去除-Ca-2-和-Ba-2-离子" class="headerlink" title="第四步：去除$Ca^{2+}$和$Ba^{2+}$离子"></a>第四步：去除$Ca^{2+}$和$Ba^{2+}$离子</h4><p>向溶液中加入$Na_2CO_3$<br>要求：过量<br>化学方程式：$CaCl_2+Na_2CO_3\xlongequal{\hspace{1.5cm}}CaCO_3\downarrow+2NaCl$<br>                       $BaCl_2+Na_3CO_3\xlongequal{\hspace{1.5cm}}BaCO_3\downarrow+2NaCl$<br>离子方程式：$Ca^{2+}+CO_3^{2-}\xlongequal{\hspace{1.5cm}}CaCO_3\downarrow$<br>                       $Ba^{2+}+CO_3^{2-}\xlongequal{\hspace{1.5cm}}BaCO_3\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$NaOH$、$Na_2CO_3$<br>剩余离子：$Na^+$、$Cl^-$、$OH^-$、$CO_3^{2+}$<br>剩余沉淀：$Mg(OH)_2$、$BaSO_4$、$CaCO_3$、$BaCO_3$</p><h4 id="第五步：去除沉淀"><a href="#第五步：去除沉淀" class="headerlink" title="第五步：去除沉淀"></a>第五步：去除沉淀</h4><p>过滤即可，实验室操作中注意玻璃棒引流<br>剩余溶质：$NaCl$、$NaOH$、$Na_2CO_3$<br>剩余离子：$Na^+$、$Cl^-$、$OH^-$、$CO_3^{2+}$<br>注：如果这一步不进行，$CaCO_3$和$BaCO_3$沉淀将与第六步加入的$HCl$反应，重新生成$CaCl_2$和$BaCl_2$</p><h4 id="第六步：去除-OH-和-CO-3-2-离子"><a href="#第六步：去除-OH-和-CO-3-2-离子" class="headerlink" title="第六步：去除$OH^-$和$CO_3^{2+}$离子"></a>第六步：去除$OH^-$和$CO_3^{2+}$离子</h4><p>向溶液中加入$HCl$<br>要求：适量加入，直到恰好不再产生气体为止，也可用PH试纸反复测定直到7时停止<br>化学方程式：$NaOH+HCl\xlongequal{\hspace{1.5cm}}NaCl+H_2O$<br>                       $Na_2CO_3+2HCl\xlongequal{\hspace{1.5cm}}2NaCl+CO_2\uparrow+H_2O$<br>离子方程式：$OH^-+H^+\xlongequal{\hspace{1.5cm}}H_2O$<br>                       $CO_3^{2-}+2H^+\xlongequal{\hspace{1.5cm}}Ca^{2+}+CO_2\uparrow+H_2O$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$<br>剩余离子：$Na^+$、$Cl^-$<br>注：过量$HCl$不会产生影响，会在第七步蒸发掉，生成$HCl$气体</p><h4 id="第七步：蒸发结晶"><a href="#第七步：蒸发结晶" class="headerlink" title="第七步：蒸发结晶"></a>第七步：蒸发结晶</h4><p>晾晒即可，实验室用蒸发皿和酒精灯时注意玻璃棒搅拌，有大量固体时停止加热</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>物理变化：晒制粗盐、过滤难溶性杂质、蒸发结晶等。<br>化学变化：去除钙镁离子及硫酸根时用加入物质的方法生成沉淀。<br>重要考点：复分解反应，实质是离子结合生成沉淀、气体和水的过程。<br>注：$NaOH$的加入顺序可调整，只要在$HCl$前就可以，但其他顺序不可调整。</p><p>化学老师说过，化学的作用就是：“想要的东西创造出来，不想要的东西给消灭掉。”粗盐精制正是这句话的完美体现。</p><p>什么？你想下载这篇文章？<a href="https://wenku.baidu.com/view/0f446d9e17791711cc7931b765ce05087632758f.html">打钱</a>！</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Chemistry</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Anecdotes from Class 6</title>
    <link href="/2023/12/03/Anecdotes-from-Class-6/"/>
    <url>/2023/12/03/Anecdotes-from-Class-6/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{2021级6班趣闻}<br>$$</p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>本篇文章由<a href="/2023/12/02/About-Me">gtr</a>汇总整理，记录了九上学习中的趣闻。如有冒犯请<a href="/about">联系我</a>删除。<br>山大辅仁2021级6班共37人，班主任Ma Sun，副班主任Ch Guo。<br>许多科目都换了老师QWQ，这里先只说九上的事。</p><hr><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>老师：<br>$\begin{array}{|c|c|}<br>\hline\text{教授科目}&amp;\text{文中代名}\\<br>\hline\text{语文}&amp;\text{Ch Guo}\\<br>\hline\text{数学}&amp;\text{Ma Sun}\\<br>\hline\text{英语}&amp;\text{En Zhang}\\<br>\hline\text{物理}&amp;\text{Ph Yang}\\<br>\hline\text{化学}&amp;\text{Ch Yang}\\<br>\hline\text{信息}&amp;\text{IT Ji}\\<br>\hline\text{体育}&amp;\text{Ph Zhang}\\<br>\hline\text{历史}&amp;\text{Hi Wang}\\<br>\hline\end{array}$</p><p>学生：<br>文中为姓名首字母。</p><hr><h4 id="23-09-04-扫雷失败"><a href="#23-09-04-扫雷失败" class="headerlink" title="23&#x2F;09&#x2F;04 扫雷失败"></a>23&#x2F;09&#x2F;04 扫雷失败</h4><p>gtr: 我们偷偷把麦斯拿回家做吧。<br>qsy: 把麦斯炸了。</p><blockquote><p>麦斯扫雷，学校发的数学题，九上不让带回家也不让提前做。</p></blockquote><hr><h4 id="23-09-05-奖罚易主"><a href="#23-09-05-奖罚易主" class="headerlink" title="23&#x2F;09&#x2F;05 奖罚易主"></a>23&#x2F;09&#x2F;05 奖罚易主</h4><p>En Zhang: 最近lcl，zyzx的作业做得不错，提出表扬。<br>En Zhang: lyc，gtr过来一下。</p><blockquote><p>这二位默写没写课文原词，被警告。</p></blockquote><hr><h4 id="23-09-07-证在心里"><a href="#23-09-07-证在心里" class="headerlink" title="23&#x2F;09&#x2F;07 证在心里"></a>23&#x2F;09&#x2F;07 证在心里</h4><p>Ma Sun: 都记下来了吗？你写了吗？<br>zyzx: 写了。<br>Ma Sun: 写哪了？<br>zyzx: 这里。<br>Ma Sun: 证明过程呢？在哪？<br>zyzx: 证在心里了。</p><hr><h4 id="23-09-13-下酒题"><a href="#23-09-13-下酒题" class="headerlink" title="23&#x2F;09&#x2F;13 下酒题"></a>23&#x2F;09&#x2F;13 下酒题</h4><p>Ma Sun: ljq干啥呢，怎么还做题呢？<br>ljq: 看看。<br>Ma Sun: 人家吃下酒菜，你是下酒题吧，吃饭。</p><hr><h4 id="23-09-18-地理75足矣"><a href="#23-09-18-地理75足矣" class="headerlink" title="23&#x2F;09&#x2F;18 地理75足矣"></a>23&#x2F;09&#x2F;18 地理75足矣</h4><blockquote><p>校内初高衔接小测，教室后面发现一张计划表。<br>$\begin{array}{|c|c|c|c|}<br>\hline语文&amp;12*&amp;数学&amp;145\\<br>\hline英语&amp;14*&amp;地理&amp;75\\<br>\hline生物&amp;98&amp;历史&amp;98\\<br>\hline道法&amp;100&amp;\cdots&amp;\cdots\\<br>\hline\end{array}$</p></blockquote><hr><h4 id="23-09-26-爆装备了"><a href="#23-09-26-爆装备了" class="headerlink" title="23&#x2F;09&#x2F;26 爆装备了"></a>23&#x2F;09&#x2F;26 爆装备了</h4><p>ljq: 爆装备了，四个金币。  </p><blockquote><p>体育课，操场上四个卫生纸团。</p></blockquote><hr><h4 id="23-10-03-就不加"><a href="#23-10-03-就不加" class="headerlink" title="23&#x2F;10&#x2F;03 就不加"></a>23&#x2F;10&#x2F;03 就不加</h4><p>tmc: 所以说，是无水硫酸铜，还是五水硫酸铜？<br>gtr: 加个“合”就可以了，五水合硫酸铜。<br>tmc: 就不加。</p><hr><h4 id="23-10-07-可以食言"><a href="#23-10-07-可以食言" class="headerlink" title="23&#x2F;10&#x2F;07 可以食言"></a>23&#x2F;10&#x2F;07 可以食言</h4><p>gtr: 不是说跑两圈吗，怎么食言了？<br>zyzx: 当然可以食言了，盐已经被英语老师听写完了。</p><blockquote><p>早读刚听写完单词salty。</p></blockquote><hr><h4 id="23-10-09-发芽了"><a href="#23-10-09-发芽了" class="headerlink" title="23&#x2F;10&#x2F;09 发芽了"></a>23&#x2F;10&#x2F;09 发芽了</h4><p>Ma Sun: 就你们两个组没浇水，怎么还没发芽？<br>wzh: 老师，其实发芽了，只不过没浇水干死了。</p><hr><h4 id="23-10-09-你们活该"><a href="#23-10-09-你们活该" class="headerlink" title="23&#x2F;10&#x2F;09 你们活该"></a>23&#x2F;10&#x2F;09 你们活该</h4><p>Ma Sun: 昨天月考，我们班有同学作弊，这里不说是谁了，ta应该自己知道。……那位同学，猜到了，算你们赢；猜不到，你们活该。</p><hr><h4 id="23-10-10-调戏"><a href="#23-10-10-调戏" class="headerlink" title="23&#x2F;10&#x2F;10 调戏"></a>23&#x2F;10&#x2F;10 调戏</h4><p>Ch Guo: wcy，你来概括一下拳打镇关西。<br>wcy: ……第二天鲁智深调戏了镇关西。</p><blockquote><p>应该是第二天鲁智深捉弄了镇关西一番，然后痛打镇关西三拳，拳拳正中要害，镇关西一命呜呼。</p></blockquote><hr><h4 id="23-10-11-废话"><a href="#23-10-11-废话" class="headerlink" title="23&#x2F;10&#x2F;11 废话"></a>23&#x2F;10&#x2F;11 废话</h4><p>En Zhang: “talk to”和”talk with”有什么区别啊，hyx？<br>hyx: 一个后面是”to”，一个后面是”with”。<br>En Zhang: 你这不废话吗。</p><hr><h4 id="23-10-27-超导体"><a href="#23-10-27-超导体" class="headerlink" title="23&#x2F;10&#x2F;27 超导体"></a>23&#x2F;10&#x2F;27 超导体</h4><p>Ph Yang: 好，根据$R&#x3D;\frac{U}{I}$，我说，电阻和电压成正比，电阻和电流成反比，对不对？<br>class: 不对。<br>Ph Yang: 电阻跟什么有关？<br>class: 长度，横截面积，材料，温度。<br>Ph Yang: 那电阻和电流有没有关系？<br>class: 没有。<br>Ph Yang: 和电压有没有关系？<br>class: 没有。<br>Ph Yang: 电压为零，电流为零，导体有没有电阻？<br>class: 没有。<br>Ph Yang: 那你们自己通电了吗？照你们这么说你们都没有电阻，早就被抓去做实验去了。</p><blockquote><p>惯性思维，导致全班下意识喊出“没有”。</p></blockquote><hr><h4 id="23-10-30-统统扔掉"><a href="#23-10-30-统统扔掉" class="headerlink" title="23&#x2F;10&#x2F;30 统统扔掉"></a>23&#x2F;10&#x2F;30 统统扔掉</h4><p>gtr: 这两个U盘分不清了，一个是Ch Guo的，一个是En Zhang的。<br>qsy: 管它呢，全给它扔垃圾桶里。</p><hr><h4 id="23-10-30-诶嘿，忘啦！"><a href="#23-10-30-诶嘿，忘啦！" class="headerlink" title="23&#x2F;10&#x2F;30 诶嘿，忘啦！"></a>23&#x2F;10&#x2F;30 诶嘿，忘啦！</h4><hr><h4 id="23-10-31-极限摸鱼"><a href="#23-10-31-极限摸鱼" class="headerlink" title="23&#x2F;10&#x2F;31 极限摸鱼"></a>23&#x2F;10&#x2F;31 极限摸鱼</h4><p>lyc: 就这半个足球场，我八步就跳过去了。</p><blockquote><p>体育课力量练习，我们需要蛙跳跳过半个足球场，lyc他们的策略是跳出老师视线之后跑到终点。</p></blockquote><hr><h4 id="23-11-02-上天的旨意"><a href="#23-11-02-上天的旨意" class="headerlink" title="23&#x2F;11&#x2F;02 上天的旨意"></a>23&#x2F;11&#x2F;02 上天的旨意</h4><p>lyc: 随机抽学号上来分享。来，ljq。<br>ljq: 不是抽学号吗？<br>lyc: 好，抽学号。$\small\textcolor{darkgrey}{随后找到音频，划了一下。}$来，16号。<br>ljq: $\small\textcolor{darkgrey}{拿着lyc的思维导图上台分享。}$</p><blockquote><p>语文现代文答题思路结构化展示，Ch Guo指定lyc安排。<br>我们班取随机数最朴素的方法是取一个较长的音频，随机划一下，二位秒数就是取的随机数。这个方法由gtr提议。虽然后来用了gtr写的随机数代码，但换了教室后就没再拷过来。</p></blockquote><hr><h4 id="23-11-03-复活点"><a href="#23-11-03-复活点" class="headerlink" title="23&#x2F;11&#x2F;03 复活点"></a>23&#x2F;11&#x2F;03 复活点</h4><p>lyc: 到复活点了，因为上一圈被刷下去的这一圈会在这里复活。</p><blockquote><p>每天四圈环校跑，上午下午各两圈，每圈1000米。<br>校门口有大上坡，第一圈体力不支的会选择停下，躲在树后面，等队伍套圈后再出来继续跟队跑。</p></blockquote><hr><h4 id="23-11-06-有理有据"><a href="#23-11-06-有理有据" class="headerlink" title="23&#x2F;11&#x2F;06 有理有据"></a>23&#x2F;11&#x2F;06 有理有据</h4><p>Ch Yang: 你要灭火，首先要干啥？<br>class: 要有火。</p><blockquote><p>化学课，学习燃烧条件。</p></blockquote><hr><h4 id="23-11-09-记仇的monitor"><a href="#23-11-09-记仇的monitor" class="headerlink" title="23&#x2F;11&#x2F;09 记仇的monitor"></a>23&#x2F;11&#x2F;09 记仇的monitor</h4><p>Ma Sun: 说一件事，lyc今天早上被抓到没按地方下车。下次不允许了。</p><p>zsh: 怎么回事？<br>lyc: 怎么了？<br>zsh: $\small\textcolor{darkgrey}{沉重语气：}$怎么没按地方下车？<br>class: $\small\textcolor{darkgrey}{Laughed.}$<br>lyc: 安静安静。<br>zsh: $\small\textcolor{darkgrey}{细声：}$Monitor~ Monitor~<br>class: $\small\textcolor{darkgrey}{Laughed.}$<br>lyc: 安静！再笑的记名字了！</p><p>zsh: 班长可以去接水吗？<br>lyc: 回位坐着去，你是闲的还是闲的还是闲的还是闲的啊？</p><blockquote><p>Ma Sun前天刚刚强调了校门口家长接送下车位置，lyc家长忘了，导致被抓住记了名。<br>Monitor这个外号来自一次英语公开课，中文意思是班长。当时全班基本上没有人愿意举手回答问题，所以老师只能问：”Who would like to share your opinion? … Monitor, please stand up and answer my question.”</p></blockquote><hr><h4 id="23-11-11-新型伸展跳"><a href="#23-11-11-新型伸展跳" class="headerlink" title="23&#x2F;11&#x2F;11 新型伸展跳"></a>23&#x2F;11&#x2F;11 新型伸展跳</h4><p>Ph Zhang: 怎么跳呢，跟蛤蟆似的。</p><blockquote><p>伸展跳，lyc没伸展开，双手和膝盖弯曲。</p></blockquote><hr><h4 id="23-11-16-亮了，亮了"><a href="#23-11-16-亮了，亮了" class="headerlink" title="23&#x2F;11&#x2F;16 亮了，亮了"></a>23&#x2F;11&#x2F;16 亮了，亮了</h4><p>zlj: 闭合开关$S_1$和$S_2$时，灯泡亮，电铃也亮。</p><hr><h4 id="23-11-16-突然文雅"><a href="#23-11-16-突然文雅" class="headerlink" title="23&#x2F;11&#x2F;16 突然文雅"></a>23&#x2F;11&#x2F;16 突然文雅</h4><p>zyx: 今天迟到的有，xxx，xxx……<br>Ma Sun: 这个声音，不甚清楚。<br>class: $\small\textcolor{darkgrey}{Confused.}$<br>Ch Guo: 不是很清楚，不是很清楚。</p><hr><h4 id="23-11-16-吟诗一首"><a href="#23-11-16-吟诗一首" class="headerlink" title="23&#x2F;11&#x2F;16 吟诗一首"></a>23&#x2F;11&#x2F;16 吟诗一首</h4><p>lcs: 有tr和jq官比我大，<br>      还有zyx我根本不怕。<br>     如果明天孙翔找我爸，<br>  我直接扑通一声给他跪下。</p><blockquote><p>当天晚自习路队很乱，人少，班长lyc和值班的Ch Guo都掉队了。</p></blockquote><hr><h4 id="23-11-27-最难的题"><a href="#23-11-27-最难的题" class="headerlink" title="23&#x2F;11&#x2F;27 最难的题"></a>23&#x2F;11&#x2F;27 最难的题</h4><p>zlj: 这道题难吗？<br>gtr: 不难。<br>zlj: 确实不难。我觉得最难的是这道题。<br>gtr: $\small\textcolor{darkgrey}{愣了一下。}$嗯，确实，许多大数学家都搞不清楚这个数的意义是什么。<br>zlj: 还有这个！这个也非常难。<br>gtr: 确实，每个答案看上去都对，实际上没有恰当的答案。  </p><blockquote><p>第一个是个性超市下面的页码，第二个是封面上的名字。</p></blockquote><hr><h4 id="23-11-29-凭空产生"><a href="#23-11-29-凭空产生" class="headerlink" title="23&#x2F;11&#x2F;29 凭空产生"></a>23&#x2F;11&#x2F;29 凭空产生</h4><p>Ch Yang: 来，zxh，上黑板上默写化学方程式。<br>Ch Yang: ……第三个，盐酸除铁锈。<br>zxh: $Fe_2O_3+2HCl\xlongequal{\hspace{0.7cm}}H_2O+CO_2\uparrow+2NaCl$。</p><hr><h4 id="23-11-29-一会下来"><a href="#23-11-29-一会下来" class="headerlink" title="23&#x2F;11&#x2F;29 一会下来"></a>23&#x2F;11&#x2F;29 一会下来</h4><p>IT Ji: wxm去哪了？<br>lss: 他被英语老师留下了，一会下来。  </p><blockquote><p>然而，微机室在五楼，上面没有其它楼层。</p></blockquote><hr><h4 id="23-11-30-化学老师生气了"><a href="#23-11-30-化学老师生气了" class="headerlink" title="23&#x2F;11&#x2F;30 化学老师生气了"></a>23&#x2F;11&#x2F;30 化学老师生气了</h4><p>Ch Yang: 来，zsh，上来默写方程式。<br>zsh: $Fe_2O_3+HSO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+H_2O$<br>zsh: $Fe_2O_3+3HSO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+3H_2O$<br>zsh: $2Fe_2O_3+6HSO_4\xlongequal{\hspace{0.7cm}}2Fe_2(SO_4)_3+3H_2O$<br>Ch Yang: 回去吧。给你个机会，100遍硫酸。<br>zsh: $Fe_2O_3+3H_2SO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+3H_2O$<br>Ch Yang: 化学式都写不对，配配配，配你……$\small\textcolor{darkgrey}{扶额，停顿了两秒}$<br>class: $\small\textcolor{darkgrey}{Laughed.}$</p><hr><h4 id="23-12-01-填满"><a href="#23-12-01-填满" class="headerlink" title="23&#x2F;12&#x2F;01 填满"></a>23&#x2F;12&#x2F;01 填满</h4><p>Ch Guo: 先达德隆望尊，门人弟子填其室，未敢稍降辞色。lcs，你来翻译一下这个句子。<br>lcs: 先辈德高望重，门人学生填满了他的房间……</p><blockquote><p>填：挤满。</p></blockquote><hr><h4 id="23-12-01-初三真好"><a href="#23-12-01-初三真好" class="headerlink" title="23&#x2F;12&#x2F;01 初三真好"></a>23&#x2F;12&#x2F;01 初三真好</h4><p>En Zhang: ……，一会这些同学留下来重新默写，到三班去找我。<br>lcs: 上面是什么声音？他们不考试吗？<br>qsy: 就我们三个班考。<br>class: 啊……<br>Ch Guo: 多么幸福的初三生活啊！<br>Ch Guo: 一会古诗默写不合格的留下来补。<br>lcs: 不是明天不上课了，是移到今天晚上了。<br>qsy: 好，直接在这上晚自习。</p><blockquote><p>由于学校有活动，周六不需要上课了。<br>自习课考物理，但只有Ph Yang带的4班、5班和6班考。<br>楼上九班不考试，在搬桌子，哐当哐当的。<br>qsy所言既是，18:30放学，还差5分钟开始上晚自习。</p></blockquote><hr><h4 id="23-12-15-一瓶"><a href="#23-12-15-一瓶" class="headerlink" title="23&#x2F;12&#x2F;15 一瓶"></a>23&#x2F;12&#x2F;15 一瓶</h4><p>Ch Fang: $NaCl$沸点1465℃……现在花掉1000元，容不容易啊？我们十班那小孩一瓶鞋子花了1000多块钱</p><hr><h4 id="23-12-21-沉默是金"><a href="#23-12-21-沉默是金" class="headerlink" title="23&#x2F;12&#x2F;21 沉默是金"></a>23&#x2F;12&#x2F;21 沉默是金</h4><p>Ch Yang: $Na_2CO_3$除$NaOH$，加什么，来，有主动的吗？<br>lcs: 沉默是金。<br>Ch Yang: 沉默是金……来，jjh。</p><h4 id="23-12-24-正解"><a href="#23-12-24-正解" class="headerlink" title="23&#x2F;12&#x2F;24 正解"></a>23&#x2F;12&#x2F;24 正解</h4><blockquote><p>对于诗句“饿死真吾志，梦中行采薇”的理解，下列说法正确的一项是？<br>D. 文天祥受元朝虐待，不给饭吃，只好在梦中采野菜吃。</p></blockquote><hr><h4 id="23-12-26-半径"><a href="#23-12-26-半径" class="headerlink" title="23&#x2F;12&#x2F;26 半径"></a>23&#x2F;12&#x2F;26 半径</h4><p>lcs: 半径！<br>ljq: 安静！<br>lcs: 连半径！这个是弦！<br>ljq: 安静，一会记名字了！<br>lcs: 那叫半径！</p><hr><h4 id="23-12-29-轮子"><a href="#23-12-29-轮子" class="headerlink" title="23&#x2F;12&#x2F;29 轮子"></a>23&#x2F;12&#x2F;29 轮子</h4><p>Hi Wang: 快，《论语》是谁写的？你们不都学过吗？<br>lcs: 论子写的。</p><hr><h4 id="24-01-02-数学代入历史"><a href="#24-01-02-数学代入历史" class="headerlink" title="24&#x2F;01&#x2F;02 数学代入历史"></a>24&#x2F;01&#x2F;02 数学代入历史</h4><p>Hi Wang: 秦始皇统一货币，使用圆形方孔半两钱，又称“秦半两”。<br>lcs: 圆内接四边形。</p><hr><h4 id="24-01-09-潦草"><a href="#24-01-09-潦草" class="headerlink" title="24&#x2F;01&#x2F;09 潦草"></a>24&#x2F;01&#x2F;09 潦草</h4><p>xwh: 老师，作业太潦草了怎么办？<br>En Zhang: 太潦草了怎么办？重写一遍就不潦草了。</p><hr><h4 id="24-01-10-生日快乐"><a href="#24-01-10-生日快乐" class="headerlink" title="24&#x2F;01&#x2F;10 生日快乐"></a>24&#x2F;01&#x2F;10 生日快乐</h4><p>zsh: 全体目光对准xwh！生日快乐！<br>class: $\small\textcolor{darkgrey}{Clapped.}$<br>wsc: 一月十号，诶，十号！<br>class: $\small\textcolor{darkgrey}{Shouted.}$</p><p>gtr: 十五岁啦！长大啦！<br>xwh: 生日考道法，一点也不快乐。<br>wsc: 要找自己的”Other Half”了！</p><hr><h4 id="24-01-30-老大"><a href="#24-01-30-老大" class="headerlink" title="24&#x2F;01&#x2F;30 老大"></a>24&#x2F;01&#x2F;30 老大</h4><p>gtr: 我刚从校门口进来，看到Ch Yang开车进来了。<br>lcs: 居然不是直升机，差评。</p><blockquote><p>为什么Ch Yang的外号叫“老大”，要追溯到原子相对质量。<br>Ch Yang: 取$_6^{12}C$原子质量的$\frac{1}{12}$作为相对原子质量的单位。我是老大，我就是这么规定的。</p></blockquote><hr><h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h4><p>九上很快，很短，也很愉快。<br>这是我们人生中的一抹彩。</p><hr><h4 id="招人"><a href="#招人" class="headerlink" title="招人"></a>招人</h4><p>有没有人愿意续写？请<a href="/about">联系我</a>，谢谢！</p><hr><p>$\normalsize\hspace{0.5cm}\textcolor{darkgrey}{-}\hspace{0.5cm}\LARGE^\textcolor{purple}{\textbf{未}}\large\textcolor{darkgreen}{\textbf{完}}\Large^\textcolor{darkblue}{\textbf{待}}\LARGE_\textcolor{red}{\textbf{续}}\normalsize\hspace{0.5cm}\textcolor{darkgrey}{-}\hspace{0.5cm}$</p>]]></content>
    
    
    <categories>
      
      <category>Notes &amp; Collations</category>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About Me</title>
    <link href="/2023/12/02/About-Me/"/>
    <url>/2023/12/02/About-Me/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\Large\textbf{关于我}<br>$$</p><hr><h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><p>Taoran<br>来自山大辅仁学校 2015级7班 &amp; 2021级6班，文化课成绩一般。<br>一名普普通通的$\text{OIer}$，成绩十分不出众，机房里最菜的一个。<br>$$<br>\Large{\textcolor{black}{\textbf{长}}}<br>\LARGE{_\textcolor{black}{\textbf{江}}}<br>\LARGE{^\textcolor{darkred}{\textbf{后}}}<br>\large{\textcolor{darkred}{\textbf{浪}}}<br>\Large{^\textcolor{black}{\textbf{推}}}<br>\LARGE{_\textcolor{darkgreen}{\textbf{前}}}<br>\LARGE{^\textcolor{darkgreen}{\textbf{浪}}}<br>\large{\textcolor{black}{\textbf{，}}}<br>\large{\textcolor{black}{\textbf{世}}}<br>\LARGE{_\textcolor{black}{\textbf{上}}}<br>\LARGE{^\textcolor{red}{\textbf{新}}}<br>\large{\textcolor{red}{\textbf{人}}}<br>\Large{\textcolor{black}{\textbf{赶}}}<br>\LARGE{^\textcolor{purple}{\textbf{旧}}}<br>\LARGE{_\textcolor{purple}{\textbf{人}}}<br>\LARGE{_\textcolor{black}{\textbf{。}}}<br>$$</p><hr><h3 id="码风"><a href="#码风" class="headerlink" title="码风"></a>码风</h3><p>一直用快读，不用<code>cin</code>和<code>cout</code>。<br>不喜欢用万能头<br>数组的名字叫<code>d[]</code>，<code>g[]</code>和<code>f[]</code>，从1开始。<br>不常用<code>const int</code>，一般是<code>#define</code>  。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//freopen(&quot;***.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;***.out&quot;, &quot;w&quot;, stdout);</span><br><br><span class="hljs-comment">//fclose(stdin);</span><br><span class="hljs-comment">//fclose(stdout);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="打OI的步骤"><a href="#打OI的步骤" class="headerlink" title="打OI的步骤"></a>打OI的步骤</h3><p>暴一；骗二；Rand(三)；<code>system(&quot;shutdown -s -t 0&quot;)</code>四。</p><hr><h3 id="原笔记-链接表"><a href="#原笔记-链接表" class="headerlink" title="原笔记&amp;链接表"></a>原笔记&amp;链接表</h3><p>详见洛谷<a href="https://www.luogu.com.cn/paste/tioy7p8y">剪贴板</a></p><hr><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>详见 <a href="/about">About</a> 页面</p>]]></content>
    
    
    <categories>
      
      <category>Introductions</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
